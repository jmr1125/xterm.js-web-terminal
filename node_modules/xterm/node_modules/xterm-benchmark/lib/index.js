"use strict";
/**
 * TODO:
 *    - timeout option
 *    - test cases
 *    - TimelineRunner options
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalRun = exports.showBaselineData = exports.showTree = exports.run = exports.ThroughputRuntimeCase = exports.RuntimeCase = exports.perfContext = exports.afterEach = exports.after = exports.beforeEach = exports.before = exports.PerfCase = exports.EVAL_CONFIG = exports.LOGPATHS = exports.CMDLINE_OVERRIDES = exports.DEFAULT_OPTIONS = void 0;
const interfaces_1 = require("./interfaces");
const path = require("path");
const child_process_1 = require("child_process");
const mixins_1 = require("./mixins");
const fs = require("fs");
const helper_1 = require("./helper");
const columnify = require('columnify');
// default perfcase settings, override with config file or cmdline options
exports.DEFAULT_OPTIONS = {
    fork: false,
    repeat: 1
};
exports.CMDLINE_OVERRIDES = {};
const INDENT = '   ';
exports.LOGPATHS = [];
// defaults for eval, override with a config file
const DEFAULT_TOLERANCE = [0.25, 4.0];
exports.EVAL_CONFIG = {
    tolerance: { '*': DEFAULT_TOLERANCE },
    skip: [],
};
// create regexp string for eval config filter
const FILTER_FN = (token) => token.replace('|', '[|]').replace('.', '[.]').replace('*', '.+?');
/**
 * Global symbol stack.
 * This is used to load the symbols for the next context:
 *    - enclosing callback triggers exported symbols functions which add itself to the stack
 *    - PerfContext.constructor consumes the symbols (empties stack)
 *    - PerfContext.run calls symbols callbacks, which either:
 *        - enclose a child context -> spawn new context
 *        - trigger a perf cases
 *        - do some before/after work
 * Never change the underlying object, always pop from the original.
 */
const STACK = [];
function addToStack(token) {
    // we dont rely on unique names, but need identity for contexts and cases
    // therefore we fix names by appending an incrementing number
    if (token.type === interfaces_1.PerfType.Context || token.type === interfaces_1.PerfType.PerfCase) {
        const stackNames = STACK.map(el => el.name);
        if (stackNames.indexOf(token.name) !== -1) {
            let num = 0;
            while (stackNames.indexOf(token.name + '#' + ++num) !== -1)
                ;
            token.name += '#' + num;
        }
    }
    STACK.push(token);
}
/**
 * PerfContext
 *
 * Runtime representation of a `perfContext` enclosure for perf cases with
 * `before`, `beforeEach`, `after` and `afterEach` support.
 * Note that a file will automatically get a toplevel context with
 * the filename as `.name`.
 * For preparation/cleanup methods only one of each kind is respected. This is
 * not enforced so a later definition will override an earlier one.
 * They can be defined at any position in the context callback (even top level),
 * beside that JS lexical scoping rules apply as expected.
 *
 * preparation/cleanup invocation logic for a single perf file:
 *    ctx.create
 *      ctx.before
 *      ctx.beforeEach
 *        perfcase.run | sub_ctx.create
 *      ctx.afterEach
 *      ctx.after
 *
 * Sub contexts are created lazy in `.run` when needed.
 * It is possible to run a single perf case from the cmdline. This will trigger
 * all preparation methods on the way down and all cleanup methods on the way up,
 * but not invoke any methods of siblings. Special care is needed if you rely
 * on state changes from neighbors (simply dont do it).
 */
class PerfContext {
    constructor(name, parent = null) {
        this.name = name;
        this.parent = parent;
        this.before = () => { };
        this.beforeEach = () => { };
        this.after = () => { };
        this.afterEach = () => { };
        // to preserve invocation order we put runners and sub contexts in just one list
        // and do the further tree expanding lazy in .run
        this.contextsOrCases = [];
        let entry;
        // Note: removes current items in the global stack
        // this is needed so any sub context can cleanly init
        while (entry = STACK.shift()) {
            switch (entry.type) {
                case interfaces_1.PerfType.before:
                    this.before = entry.callback;
                    break;
                case interfaces_1.PerfType.beforeEach:
                    this.beforeEach = entry.callback;
                    break;
                case interfaces_1.PerfType.after:
                    this.after = entry.callback;
                    break;
                case interfaces_1.PerfType.afterEach:
                    this.afterEach = entry.callback;
                    break;
                case interfaces_1.PerfType.Context:
                    this.contextsOrCases.push(entry);
                    break;
                case interfaces_1.PerfType.PerfCase:
                    this.contextsOrCases.push(entry);
                    break;
                default:
            }
        }
    }
    getPath() {
        let parents = [];
        let elem = this.parent;
        while (elem) {
            parents.unshift(elem.name);
            elem = elem.parent;
        }
        parents.push(this.name);
        return parents;
    }
    getPathString() {
        return this.getPath().join('|');
    }
    runFull() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`${INDENT.repeat(this.getPath().length)}Context "${this.name}"`);
            try {
                yield this.before();
                for (let i = 0; i < this.contextsOrCases.length; ++i) {
                    try {
                        yield this.beforeEach();
                        if (this.contextsOrCases[i].type === interfaces_1.PerfType.Context) {
                            while (STACK.pop()) { }
                            yield this.contextsOrCases[i].callback();
                            const ctx = new PerfContext(this.contextsOrCases[i].name, this);
                            yield ctx.runFull();
                        }
                        else {
                            yield this.contextsOrCases[i].run(this.getPath());
                        }
                    }
                    finally {
                        yield this.afterEach();
                    }
                }
            }
            finally {
                yield this.after();
            }
        });
    }
    runSingle(treePath, forked = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let needle = treePath.shift();
            if (!needle) {
                return this.runFull();
            }
            if (!forked) {
                console.log(`${INDENT.repeat(this.getPath().length)}Context "${this.name}"`);
            }
            try {
                yield this.before();
                for (let i = 0; i < this.contextsOrCases.length; ++i) {
                    if (this.contextsOrCases[i].name === needle) {
                        try {
                            yield this.beforeEach();
                            if (this.contextsOrCases[i].type === interfaces_1.PerfType.Context) {
                                while (STACK.pop()) { }
                                this.contextsOrCases[i].callback();
                                const ctx = new PerfContext(this.contextsOrCases[i].name, this);
                                yield ctx.runSingle(treePath, forked);
                            }
                            else {
                                yield this.contextsOrCases[i].run(this.getPath(), forked);
                            }
                            yield this.afterEach();
                            yield this.after();
                            return;
                        }
                        finally {
                            yield this.afterEach();
                        }
                    }
                }
            }
            finally {
                yield this.after();
            }
            console.error(`path not found: "${this.getPath().concat(needle).join('|')}"`);
            throw new Error(`path not found: "${this.getPath().concat(needle).join('|')}"`);
        });
    }
    /**
     * Get a tree representation of the context with sub contexts and cases.
     */
    getTree() {
        const path = this.getPathString();
        return {
            name: this.name,
            type: interfaces_1.PerfType[interfaces_1.PerfType.Context],
            path: path,
            children: this.contextsOrCases.map(el => {
                if (el.type === interfaces_1.PerfType.Context) {
                    while (STACK.pop()) { }
                    el.callback();
                    const ctx = new PerfContext(el.name, this);
                    return ctx.getTree();
                }
                else {
                    return {
                        name: el.name,
                        type: interfaces_1.PerfType[interfaces_1.PerfType.PerfCase],
                        path: path + '|' + el.name
                    };
                }
            })
        };
    }
}
/**
 * PerfCase
 *
 * Base class for simple performance cases in nodejs.
 * Wraps a callback for runtime measuring and postprocessing.
 *
 * Possible Options:
 *
 *    - repeat
 *      Repeat callback n times. Defaults to 1. Forked perf cases repeat the callback
 *      within one child (no additional processes created).
 *
 *    - fork
 *      Run perf case in single mode in a child process. This is especially useful
 *      to get a clean process env without pending GC calls or busy event loop.
 *      The process is created by child_process.fork and can be customized with
 *      `forkArgs``and `forkOptions`.
 *      The results are send to the parent process via `process.send`.
 *      Note: The parent process will wait for forked perf cases results,
 *      they are not run in parallel to avoid false numbers due to heavy system usage.
 *
 * For a single run the runtime is measured with a high resolution timer, the result is stored
 * in ICaseResult along with the return value and additional run information.
 *
 * Postprocessing
 * After a single run post processing or filtering be can hooked in with `.postEach(cb)`,
 * after all runs it can be done with `.postAll(cb)`. The callbacks either get a single
 * ICaseResult or ICaseResult[] as argument. The callbacks are chained, thus for
 * `.postEach(cb1).postEach(cb2)` `cb2` will see the changes of `cb1`.
 * For often used or more complicated post actions consider using a mixin with convenient methods.
 * Note: ICaseResult is not set immutable, thus it is possible to alter and even to delete properties.
 * Altering entries is ok as long the expectations of following processors are still met.
 * Deleting is dangerous and likely to break things. Adding entries should be preferred.
 * `.postEach` has one special case - returning `null` will drop the current result,
 * thus later `.postEach` and all `postAll` callbacks will not see it
 * (useful as opt-out for unwanted results).
 *
 * TODO: Further data aggregation...
 */
class PerfCase {
    constructor(name, callback, opts) {
        this.name = name;
        this.callback = callback;
        this.type = interfaces_1.PerfType.PerfCase;
        this._single = [];
        this._all = [];
        this.results = [];
        this.summary = {};
        this.path = [];
        this.options = Object.assign({}, exports.DEFAULT_OPTIONS, opts, exports.CMDLINE_OVERRIDES);
        addToStack(this);
    }
    postEach(callback) {
        this._single.push(callback);
        return this;
    }
    postAll(callback) {
        this._all.push(callback);
        return this;
    }
    _processSingle(result) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this._single.length; ++i) {
                const altered = yield this._single[i](result, this);
                if (altered === null) {
                    return;
                }
                if (altered && altered !== result) {
                    result = altered;
                }
            }
            this.results.push(result);
        });
    }
    _processFinal() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this._all.length; ++i) {
                const altered = yield this._all[i](this.results, this);
                if (altered && altered !== this.results) {
                    this.results = altered;
                }
            }
        });
    }
    _reportResults() {
        return __awaiter(this, void 0, void 0, function* () {
            const finalReport = {
                type: 0 /* PerfCase */,
                name: this.name,
                path: this.path,
                pathString: this.path.join('|'),
                options: this.options,
                summary: this.summary
            };
            if (this.options.reportFullResults) {
                finalReport.results = this.results;
            }
            exports.LOGPATHS.forEach(path => fs.appendFileSync(path, JSON.stringify(finalReport, null) + '\n'));
        });
    }
    run(parentPath, forked = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: timeout
            this.path = parentPath.concat(this.name);
            if (this.options.fork && !forked) {
                const p = child_process_1.fork(path.join(module.filename), this.options.forkArgs || [], this.options.forkOptions);
                p.send({ case: this.path, cmdlineOverrides: exports.CMDLINE_OVERRIDES });
                yield new Promise(resolve => {
                    p.on('message', (result) => this._processSingle(result));
                    p.on('exit', _ => resolve());
                });
            }
            else {
                if (!this.options.repeat) {
                    return;
                }
                for (let repeat = 0; repeat < this.options.repeat; ++repeat) {
                    const start = process.hrtime();
                    const returnValue = yield this.callback();
                    const runtime = process.hrtime(start);
                    const result = {
                        name: this.name,
                        path: this.path,
                        runtime,
                        returnValue,
                        run: repeat + 1,
                        repeat: this.options.repeat
                    };
                    if (forked && process.send) {
                        process.send(result);
                    }
                    else {
                        yield this._processSingle(result);
                    }
                }
            }
            if (!forked) {
                yield this._processFinal();
                yield this._reportResults();
            }
        });
    }
    getIndent() {
        return INDENT.repeat(this.path.length);
    }
}
exports.PerfCase = PerfCase;
/**
 * Called once after entering a context.
 * Also applies to top level (a top level `before` will run when the file is entered).
 */
function before(callback) {
    addToStack({ type: interfaces_1.PerfType.before, name: '', callback });
}
exports.before = before;
/**
 * Called for every children before entering the child.
 * Also applies to top level.
 */
function beforeEach(callback) {
    addToStack({ type: interfaces_1.PerfType.beforeEach, name: '', callback });
}
exports.beforeEach = beforeEach;
/**
 * Called once before leaving a context.
 * Also applies to top level.
 */
function after(callback) {
    addToStack({ type: interfaces_1.PerfType.after, name: '', callback });
}
exports.after = after;
/**
 * Called for every children after leaving it.
 * Also applies to top level.
 */
function afterEach(callback) {
    addToStack({ type: interfaces_1.PerfType.afterEach, name: '', callback });
}
exports.afterEach = afterEach;
/**
 * Spawn a new perf context.
 */
function perfContext(name, callback) {
    addToStack({ type: interfaces_1.PerfType.Context, name, callback });
}
exports.perfContext = perfContext;
/**
 * Some default ctors and types.
 */
exports.RuntimeCase = mixins_1.Runtime(PerfCase);
exports.ThroughputRuntimeCase = mixins_1.Throughput(mixins_1.Runtime(PerfCase));
/**
 * Run context tree path.
 * Main entry for the cli.
 */
function run(treePath) {
    return __awaiter(this, void 0, void 0, function* () {
        while (STACK.pop()) { }
        const filename = treePath.shift();
        if (!filename) {
            return;
        }
        require(path.resolve(filename));
        const ctx = new PerfContext(filename, null);
        yield ctx.runSingle(treePath);
    });
}
exports.run = run;
/**
 * Log context tree to console.
 */
function showTree(filename) {
    require(path.resolve(filename));
    const ctx = new PerfContext(filename, null);
    console.log(JSON.stringify(ctx.getTree(), null, 2));
}
exports.showTree = showTree;
/**
 * Extract baselineData from a single perfcase log.
 */
function createBaselineData(summary) {
    const baselineData = {};
    const descendWithPath = (el, path) => {
        helper_1.mapObjectValues(el, (sub, name) => {
            if (!sub || sub instanceof Array || typeof sub === 'string' || typeof sub === 'number') {
                return;
            }
            if (sub.mean) {
                baselineData[path.concat(name).join('.')] = [
                    { stat: 'mean', base: sub.mean },
                    { stat: 'median', base: sub.median },
                    { stat: 'dev', base: sub.dev },
                    { stat: 'cv', base: sub.cv },
                    { stat: 'runs', base: sub.values.length }
                ];
            }
            else {
                descendWithPath(sub, path.concat(name));
            }
        });
    };
    descendWithPath(summary, []);
    return baselineData;
}
/**
 * Get skip/tolerance values for treePath and dataPath.
 */
function getTolerance(treePath, dataPath) {
    const path = treePath + '#' + dataPath;
    if (exports.EVAL_CONFIG.skip.filter(el => path.match(FILTER_FN(el))).pop()) {
        return null;
    }
    return Object.getOwnPropertyNames(exports.EVAL_CONFIG.tolerance).map(name => path.match(FILTER_FN(name)) ? exports.EVAL_CONFIG.tolerance[name] : null).filter(el => el).pop() || DEFAULT_TOLERANCE;
}
/**
 * Parse baselineData from a log output.
 * Also used for eval data (carried as intermediate baselineData and later merged with real baselineData).
 */
function getDataForBaseline(path) {
    const caseResults = fs.readFileSync(path, { encoding: 'utf8' }).split('\n').filter(line => line).map(line => JSON.parse(line));
    const baselineData = {};
    caseResults.forEach(entry => {
        // skip any non perf case report data
        // also abort on erroneous data
        if (entry.type === 0 /* PerfCase */) {
            baselineData[entry.pathString] = createBaselineData(entry.summary);
        }
        else if (entry.type === 3 /* Error */) {
            throw new Error('refusing to eval erroneous data');
        }
    });
    return baselineData;
}
/**
 * Expand baselineData with tolerances.
 */
function applyTolerance(data, treePath, dataPath) {
    data.forEach(el => el.tolerance = getTolerance(treePath, dataPath + '.' + el.stat));
}
/**
 * Format baselineData to show in console.
 * Handles both .showBaselineData and .runEval.
 */
function formatStats(values) {
    return columnify(values, {
        minWidth: 10,
        align: 'right',
        config: {
            stat: {
                align: 'left'
            },
            base: {
                dataTransform: (el) => (el !== '') ? Number(el).toFixed(2) : '<null>'
            },
            value: {
                dataTransform: (el) => (el !== '') ? Number(el).toFixed(2) : '<null>'
            },
            tolerance: {
                dataTransform: (el) => (el === '')
                    ? '\x1b[36mskipped\x1b[0m'
                    : el.split(',').map(el => Number(el).toFixed(2)).join('-')
            },
            change: {
                headingTransform: (_) => 'CHANGE(%)',
                dataTransform: (el) => (el !== '') ? Number(el).toFixed(2) : ''
            },
            eval: {
                dataTransform: (el) => {
                    // columnify already made string of it so parse back :(
                    switch (parseInt(el)) {
                        case interfaces_1.EvalResultState.Success:
                            return '\x1b[32mOK\x1b[0m';
                        case interfaces_1.EvalResultState.Missing:
                            return '\x1b[33mMISS\x1b[0m';
                        case interfaces_1.EvalResultState.Skipped:
                            return '\x1b[36mSKIP\x1b[0m';
                        case interfaces_1.EvalResultState.Failed:
                            return '\x1b[31mFAILED\x1b[0m';
                        default:
                            return '';
                    }
                }
            }
        }
    });
}
/**
 * Show baseline stats to be accounted.
 */
function showBaselineData(basePath) {
    const data = getDataForBaseline(basePath);
    console.log('\n### Baseline data ###');
    helper_1.mapObjectValues(data, (value, key) => {
        console.log(`"${key}"`);
        helper_1.mapObjectValues(value, (vvalue, kkey) => {
            const tolerance = getTolerance(key, kkey);
            console.log(((!tolerance) ? '\x1b[36m' : '') + INDENT + '#' + kkey + ((!tolerance) ? ' - skipped' : '') + '\x1b[0m');
            applyTolerance(vvalue, key, kkey);
            const msg = formatStats(vvalue);
            console.log(INDENT.repeat(2) + msg.split('\n').join('\n' + INDENT.repeat(2)));
        });
    });
    exports.LOGPATHS.forEach(path => fs.appendFileSync(path, JSON.stringify({ type: 1 /* Base */, data }, null) + '\n'));
}
exports.showBaselineData = showBaselineData;
/**
 * Expand baselineData with eval data and do the eval within the tolerances.
 */
function applyEval(baselineEntries, evalEntries, treePath, dataPath, stats) {
    baselineEntries.forEach((el, idx) => {
        el.tolerance = getTolerance(treePath, dataPath + '.' + el.stat);
        el.value = (evalEntries && evalEntries[idx]) ? evalEntries[idx].base : undefined;
        if (typeof el.value === 'undefined') {
            el.eval = interfaces_1.EvalResultState.Missing;
            stats.missing++;
            return;
        }
        if (!el.tolerance) {
            el.eval = interfaces_1.EvalResultState.Skipped;
            stats.skipped++;
            return;
        }
        if (el.base === 0 && el.value === 0) {
            el.change = 0;
            el.eval = interfaces_1.EvalResultState.Success;
            return;
        }
        const deviation = el.value / el.base;
        el.change = (el.value - el.base) / el.base * 100;
        if (deviation >= el.tolerance[0] && deviation <= el.tolerance[1]) {
            el.eval = interfaces_1.EvalResultState.Success;
            stats.success++;
            return;
        }
        el.eval = interfaces_1.EvalResultState.Failed;
        stats.failed++;
    });
}
/**
 * Eval run against baseline.
 */
function evalRun(basePath, evalPath) {
    const baselineData = getDataForBaseline(basePath);
    const evalData = getDataForBaseline(evalPath);
    const stats = { success: 0, missing: 0, skipped: 0, failed: 0 };
    helper_1.mapObjectValues(baselineData, (value, key) => {
        console.log(`"${key}"`);
        const evalPart = evalData[key];
        helper_1.mapObjectValues(value, (vvalue, kkey) => {
            const tolerance = getTolerance(key, kkey);
            console.log(((!tolerance) ? '\x1b[36m' : '') + INDENT + '#' + kkey + ((!tolerance) ? ' - skipped' : '') + '\x1b[0m');
            applyTolerance(vvalue, key, kkey);
            const evalSubPart = (evalPart) ? evalPart[kkey] : undefined;
            applyEval(vvalue, evalSubPart, key, kkey, stats);
            const msg = formatStats(vvalue);
            console.log(INDENT.repeat(2) + msg.split('\n').join('\n' + INDENT.repeat(2)));
        });
    });
    console.log('\n');
    console.log(`\x1b[32m Success: ${stats.success}\x1b[0m`);
    console.log(`\x1b[33m Missing: ${stats.missing}\x1b[0m`);
    console.log(`\x1b[36m Skipped: ${stats.skipped}\x1b[0m`);
    console.log(`\x1b[31m Failed: ${stats.failed}\x1b[0m`);
    const final = {
        type: 2 /* Eval */,
        data: baselineData,
        summary: stats
    };
    exports.LOGPATHS.forEach(path => fs.appendFileSync(path, JSON.stringify(final, null) + '\n'));
    return final;
}
exports.evalRun = evalRun;
/**
 * A forked call for a single perf case.
 */
if (require.main === module) {
    if (process.send) {
        process.on('message', (msg) => __awaiter(void 0, void 0, void 0, function* () {
            Object.assign(exports.CMDLINE_OVERRIDES, msg.cmdlineOverrides);
            const filename = msg.case.shift();
            require(path.resolve(filename));
            const ctx = new PerfContext(filename, null);
            yield ctx.runSingle(msg.case, true);
            process.removeAllListeners('message');
        }));
    }
}
//# sourceMappingURL=index.js.map