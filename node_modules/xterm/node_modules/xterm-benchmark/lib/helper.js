"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.descriptiveStats = exports.reshapeFn = exports.mapObjectValues = exports.zip = void 0;
const math = require("mathjs");
// zip a..n --> [[a.0 .. n.0] .. [a.X .. n.X]]
function zip(...args) {
    const names = new Set();
    for (const argc of args) {
        for (const name in argc) {
            if (name === 'length') {
                continue;
            }
            names.add(name);
        }
    }
    const result = {};
    for (const name of names) {
        result[name] = [];
        for (const argc of args) {
            result[name].push(argc[name]);
        }
    }
    return result;
}
exports.zip = zip;
// map for object values
function mapObjectValues(obj, fn) {
    const clone = Object.assign({}, obj);
    Object.getOwnPropertyNames(clone).forEach(name => clone[name] = fn(clone[name], name));
    return clone;
}
exports.mapObjectValues = mapObjectValues;
/**
 * Generate a function to extract/alter deeply nested data structures.
 * Takes a list of predefined symbols or custom functions,
 * and returns a function to be applied to the data.
 * Custom functions should accept two arguments, the first
 * being the returned element of the previous function, the second
 * being the next function in the invocation chain to be applied.
 *
 * Predefined symbols:
 *    :index    map over array elements
 *    :values   map over object values (turns result in array)
 *    :keys     iterate over object values (preserves keys)
 *    :zip      [a..n] --> [[a.0 .. n.0] .. [a.X .. n.X]]
 *    :flatten  [[a, b], [c, d]] --> [a, b, c, d]
 *    property  property access
 *
 * Example:
 * const EXAMPLE = [
 *   {a: 11, b: [1, 2, 3]},
 *   {a: 12, b: [4, 5, 6]},
 *   {a: 13, b: [7, 8, 9]},
 * ];
 * reshapeFn([':index', 'a'])(EXAMPLE);
 * --> [ 11, 12, 13 ]
 * reshapeFn([':flatten'])(reshapeFn([':index', 'b'])(EXAMPLE));
 * --> [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
 * reshapeFn([':index', ':keys',
 *   (el: any, fn: Function) => fn((el instanceof Array) ? el.map(n => ++n) : ++el)])(EXAMPLE);
 * --> [ { a: 12, b: [ 2, 3, 4 ] },
 *   { a: 13, b: [ 5, 6, 7 ] },
 *   { a: 14, b: [ 8, 9, 10 ] } ]
 *
 * @param symbols list of predefined symbols or functions
 */
function reshapeFn(symbols) {
    const PREDEFINED = {
        ':index': (ar, fn) => (ar instanceof Array) ? ar.map(fn) : undefined,
        ':values': (obj, fn) => Object.getOwnPropertyNames(obj).map(el => fn(obj[el])),
        ':zip': (obj, fn) => (obj && typeof obj[Symbol.iterator] === 'function') ? fn(zip(...obj)) : undefined,
        ':keys': (obj, fn) => (obj) ? mapObjectValues(obj, fn) : undefined,
        ':flatten': (ar, fn) => (ar instanceof Array) ? fn(ar.reduce((acc, val) => acc.concat(val), [])) : undefined,
        'PROP': (obj, prop, fn) => (obj && obj[prop] !== 'undefined') ? fn(obj[prop]) : undefined,
        'FUNC': (obj, func, fn) => (obj) ? func(obj, fn) : undefined
    };
    let tokens = symbols.slice(0);
    tokens.reverse();
    return tokens.reduce((fn, key) => (key instanceof Function)
        ? ((prev, token) => (el) => PREDEFINED['FUNC'](el, token, prev))(fn, key)
        : (PREDEFINED[key])
            ? ((prev) => (el) => PREDEFINED[key](el, prev))(fn)
            : ((prev) => (el) => PREDEFINED['PROP'](el, key, prev))(fn), (el) => el);
}
exports.reshapeFn = reshapeFn;
// rudimentary descriptive statistics
function descriptiveStats(array) {
    const mean = math.mean(array);
    const median = math.median(array);
    const dev = math.std(array);
    const cv = dev / mean;
    return { mean, median, dev, cv };
}
exports.descriptiveStats = descriptiveStats;
//# sourceMappingURL=helper.js.map